{"version":3,"file":"main.js","mappings":"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","sources":["webpack://react-indexed-db/./src/Utils.ts","webpack://react-indexed-db/./src/createDatabaseTransaction.ts","webpack://react-indexed-db/./src/createReadonlyTransaction.ts","webpack://react-indexed-db/./src/createReadwriteTransaction.ts","webpack://react-indexed-db/./src/index.tsx","webpack://react-indexed-db/./src/indexed-context.tsx","webpack://react-indexed-db/./src/indexed-db.ts","webpack://react-indexed-db/./src/indexed-hooks.ts","webpack://react-indexed-db/external commonjs \"react\"","webpack://react-indexed-db/webpack/bootstrap","webpack://react-indexed-db/webpack/startup"],"sourcesContent":["export interface Options {\n  storeName: string;\n  dbMode: IDBTransactionMode;\n  error: (e: Event) => any;\n  complete: (e: Event) => any;\n  abort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string) {\n  return db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(\n  db: IDBDatabase,\n  storeName: string,\n  reject: (errorMessage: string) => void,\n) {\n  if (!db) {\n    reject(\n      \"You need to use the openDatabase function to create a database before you query it!\",\n    );\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nexport function createTransaction(\n  db: IDBDatabase,\n  options: Options,\n): IDBTransaction {\n  const trans: IDBTransaction = db.transaction(\n    options.storeName,\n    options.dbMode,\n  );\n  trans.onerror = options.error;\n  trans.oncomplete = options.complete;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nexport function optionsGenerator(\n  type: any,\n  storeName: any,\n  reject: (e: Event) => void,\n  resolve: (e?: Event) => void,\n): Options {\n  return {\n    storeName: storeName,\n    dbMode: type,\n    error: (e: Event) => {\n      reject(e);\n    },\n    complete: () => {\n      resolve();\n    },\n    abort: (e: Event) => {\n      reject(e);\n    },\n  };\n}\n\n// export function* processRequest({ request, success, error }: any) {\n//   request.onerror = function(event: Event) {\n//     error(error);\n//     yield error;\n//   };\n//   request.onsuccess = function(evt: Event) {\n//     let cursor: IDBCursorWithValue = (<IDBRequest>evt.target).result;\n//     if (cursor) {\n//       result.push(cursor.value);\n//       cursor.continue();\n//     } else {\n//       resolve(result);\n//     }\n//   };\n// }\n","import {\n  createTransaction as defaultCreateTransaction,\n  optionsGenerator as defaultOptionsBuilder,\n} from \"./Utils\";\nimport { DBMode } from \"./indexed-db\";\n\nexport function createDatabaseTransaction(\n  database: IDBDatabase,\n  mode: DBMode,\n  storeName: string,\n  resolve: (e?: Event) => void,\n  reject: (e: Event) => void,\n  createTransaction: typeof defaultCreateTransaction = defaultCreateTransaction,\n  buildOptions: typeof defaultOptionsBuilder = defaultOptionsBuilder,\n) {\n  const options = buildOptions(mode, storeName, reject, resolve);\n  const transaction: IDBTransaction = createTransaction(database, options);\n  const store = transaction.objectStore(storeName);\n\n  return {\n    store,\n    transaction,\n  };\n}\n","import { DBMode } from \"./indexed-db\";\nimport { createDatabaseTransaction } from \"./createDatabaseTransaction\";\n\nexport function createReadonlyTransaction(\n  database: IDBDatabase,\n  store: string,\n  resolve: (payload?: any) => void,\n  reject: (e: Event) => void,\n) {\n  return createDatabaseTransaction(\n    database,\n    DBMode.readonly,\n    store,\n    resolve,\n    reject,\n  );\n}\n","import { DBMode } from \"./indexed-db\";\nimport { createDatabaseTransaction } from \"./createDatabaseTransaction\";\n\nexport function createReadwriteTransaction(\n  database: IDBDatabase,\n  store: string,\n  resolve: (e?: any) => void,\n  reject: (e: Event) => void,\n) {\n  return createDatabaseTransaction(\n    database,\n    DBMode.readwrite,\n    store,\n    resolve,\n    reject,\n  );\n}\n","export { AccessDB, IndexedDB } from \"./indexed-context\";\nexport * from \"./indexed-hooks\";\nexport * from \"./indexed-db\";\n","import React, { ReactNode } from \"react\";\nimport { DBOperations, IndexedDBConfig, Key, ObjectStoreMeta, ObjectStoreSchema, openDatabase } from \"./indexed-db\";\n\n\ntype IndexedDBProps = React.PropsWithChildren<IndexedDBConfig>\n\nconst IndexedDBContext = React.createContext<{\n  db: any;\n  name: string;\n  version: number;\n}>({\n  db: null,\n  name: null,\n  version: null,\n});\n\nconst IndexedDBProvider = IndexedDBContext.Provider;\nconst IndexedDBCosumer = IndexedDBContext.Consumer;\n\nexport function IndexedDB({\n  name,\n  version,\n  children,\n  objectStoresMeta,\n}: IndexedDBProps) {\n  objectStoresMeta.forEach(async (schema: ObjectStoreMeta) => {\n    await openDatabase(name, version, (event: any) => {\n      const db: IDBDatabase = event.currentTarget.result;\n      const objectStore = db.createObjectStore(\n        schema.store,\n        schema.storeConfig,\n      );\n      schema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n        objectStore.createIndex(schema.name, schema.keyPath, schema.options);\n      });\n    });\n  });\n  return (\n    <IndexedDBProvider value={{ db: null, name, version }}>\n      {children}\n    </IndexedDBProvider>\n  );\n}\n\ninterface AccessDBProps {\n  children: ({\n    db,\n  }: {\n    db: IDBDatabase;\n    add: <T = any>(value: T, key?: any) => Promise<number>;\n    getByID: <T = any>(id: number | string) => Promise<T>;\n    getAll: <T = any>() => Promise<T[]>;\n    update: <T = any>(value: T, key?: any) => Promise<any>;\n    deleteRecord: (key: Key) => Promise<any>;\n    openCursor: (\n      cursorCallback: (event: Event) => void,\n      keyRange?: IDBKeyRange,\n    ) => Promise<void>;\n    getByIndex: (indexName: string, key: any) => Promise<any>;\n    clear: () => Promise<any>;\n  }) => ReactNode;\n  objectStore: string;\n}\n\nexport function AccessDB({ children, objectStore }: AccessDBProps) {\n  return (\n    <IndexedDBCosumer>\n      {(value) => {\n        const { db, name, version } = value;\n        // openDatabase(name, version);\n        return children({ db, ...DBOperations(name, version, objectStore) });\n      }}\n    </IndexedDBCosumer>\n  );\n}\n","import { validateBeforeTransaction } from \"./Utils\";\nimport { createReadwriteTransaction } from \"./createReadwriteTransaction\";\nimport { createReadonlyTransaction } from \"./createReadonlyTransaction\";\n\nexport type Key =\n  | string\n  | number\n  | Date\n  | ArrayBufferView\n  | ArrayBuffer\n  | IDBKeyRange; // IDBArrayKey\nexport interface IndexDetails {\n  indexName: string;\n  order: string;\n}\n\nconst indexedDB: IDBFactory =\n  window.indexedDB ||\n  (<any>window).mozIndexedDB ||\n  (<any>window).webkitIndexedDB ||\n  (<any>window).msIndexedDB;\n\nexport function openDatabase(\n  dbName: string,\n  version: number,\n  upgradeCallback?: (e: Event, db: IDBDatabase) => void,\n) {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    const request = indexedDB.open(dbName, version);\n    let db: IDBDatabase;\n    request.onsuccess = () => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === \"function\") {\n      request.onupgradeneeded = (event: Event) => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nexport function CreateObjectStore(\n  dbName: string,\n  version: number,\n  storeSchemas: readonly ObjectStoreMeta[],\n) {\n  const request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = function(event: IDBVersionChangeEvent) {\n    const database: IDBDatabase = (event.target as any).result;\n    storeSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(\n          storeSchema.store,\n          storeSchema.storeConfig,\n        );\n        storeSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n          objectStore.createIndex(schema.name, schema.keyPath, schema.options);\n        });\n      }\n    });\n    database.close();\n  };\n  request.onsuccess = function(e: any) {\n    e.target.result.close();\n  };\n}\n\nexport function DBOperations(\n  dbName: string,\n  version: number,\n  currentStore: string,\n) {\n  // Readonly operations\n  const getAll = <T>() =>\n    new Promise<T[]>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.getAll();\n\n        request.onerror = (error) => reject(error);\n\n        request.onsuccess = function({ target: { result } }: any) {\n          resolve(result as T[]);\n        };\n      });\n    });\n\n  const getByID = <T>(id: string | number) =>\n    new Promise<T>((resolve, reject) => {\n      openDatabase(dbName, version).then((db: IDBDatabase) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.get(id);\n\n        request.onsuccess = function(event: Event) {\n          resolve((event.target as any).result as T);\n        };\n      });\n    });\n\n  const openCursor = (\n    cursorCallback: (event: Event) => void,\n    keyRange?: IDBKeyRange,\n  ) => {\n    return new Promise<void>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.openCursor(keyRange);\n\n        request.onsuccess = (event: Event) => {\n          cursorCallback(event);\n          resolve();\n        };\n      });\n    });\n  };\n\n  const getByIndex = (indexName: string, key: any) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const index = store.index(indexName);\n        const request = index.get(key);\n\n        request.onsuccess = (event: Event) => {\n          resolve((<IDBOpenDBRequest>event.target).result);\n        };\n      });\n    });\n\n  // Readwrite operations\n  const add = <T>(value: T, key?: any) =>\n    new Promise<number>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        const { store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.add(value, key);\n\n        request.onsuccess = (evt: any) => {\n          key = evt.target.result;\n          resolve(key);\n        };\n\n        request.onerror = (error) => reject(error);\n      });\n    });\n\n  const update = <T>(value: T, key?: any) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { transaction, store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n\n        transaction.oncomplete = (event) => resolve(event);\n\n        store.put(value, key);\n      });\n    });\n\n  const deleteRecord = (key: Key) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.delete(key);\n\n        request.onsuccess = (event) => resolve(event);\n      });\n    });\n\n  const clear = () =>\n    new Promise<void>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store, transaction } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n\n        transaction.oncomplete = () => resolve();\n\n        store.clear();\n      });\n    });\n\n  return {\n    add,\n    getByID,\n    getAll,\n    update,\n    deleteRecord,\n    clear,\n    openCursor,\n    getByIndex,\n  };\n}\n\nexport enum DBMode {\n  readonly = \"readonly\",\n  readwrite = \"readwrite\",\n}\n\n/**\n *   interface for data types can be extended with\n *   @example\n *   declare module 'react-indexed-db' {\n *     interface StoreDataTypes {\n *         myType: MyCustomType;\n *         myTypes: MyCustomType[];\n *     }\n *   }\n */\nexport interface StoreDataTypes {\n  string: string;\n  number: number;\n  boolean: boolean;\n  object: object;\n  bigint: bigint;\n  date: Date;\n}\n\ntype ColumnTypes = keyof StoreDataTypes;\nexport type ColumnType<K extends ColumnTypes> = StoreDataTypes[K]\n\nexport interface ObjectStoreColumn {\n  keyPath: string;\n  type?: ColumnTypes;\n}\n\nexport interface ObjectStoreSchema {\n  name: string;\n  keyPath: string;\n  type?: ColumnTypes;\n  options: { unique: boolean; [key: string]: any };\n}\n\nexport interface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n  storeSchema: readonly ObjectStoreSchema[];\n  extraColumns?: readonly ObjectStoreColumn[];\n}\n\nexport interface IndexedDBConfig {\n  name: string;\n  version: number;\n  objectStoresMeta: readonly ObjectStoreMeta[];\n}\n\n\nexport type ObjectStore<DB extends IndexedDBConfig> = DB[\"objectStoresMeta\"];\nexport type StoreName<DB extends IndexedDBConfig> = ObjectStore<DB>[number][\"store\"];\nexport type StoreMeta<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  Extract<ObjectStore<DB>[number], { store: SN }>;\n\nexport type StoreConfig<DB extends IndexedDBConfig, SN extends StoreName<DB>> = StoreMeta<DB, SN>[\"storeConfig\"]\nexport type StoreIdKey<DB extends IndexedDBConfig, SN extends StoreName<DB>> = StoreConfig<DB, SN>[\"keyPath\"];\nexport type StoreIdModel<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  { [k in StoreIdKey<DB, SN>]: string }\n\ntype StoreSchema<DB extends IndexedDBConfig, SN extends StoreName<DB>> = StoreMeta<DB, SN>[\"storeSchema\"]\nexport type StoreIxKeys<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  StoreSchema<DB, SN>[number][\"keyPath\"];\nexport type StoreIxSchema<DB extends IndexedDBConfig, SN extends StoreName<DB>, K extends StoreIxKeys<DB, SN>> =\n  Extract<StoreSchema<DB, SN>[number], { keyPath: K }>;\nexport  type StoreIxModel<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  { [k in StoreIxKeys<DB, SN>]: ColumnType<StoreIxSchema<DB, SN, k>[\"type\"]> }\n\n\ntype StoreXtSchema<DB extends IndexedDBConfig, SN extends StoreName<DB>> = StoreMeta<DB, SN>[\"extraColumns\"]\nexport type StoreXKeys<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  StoreXtSchema<DB, SN>[number][\"keyPath\"];\nexport type StoreXSchema<DB extends IndexedDBConfig, SN extends StoreName<DB>, K extends StoreXKeys<DB, SN>> =\n  Extract<StoreXtSchema<DB, SN>[number], { keyPath: K }>;\nexport  type StoreXModel<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  { [k in StoreXKeys<DB, SN>]: ColumnType<StoreXSchema<DB, SN, k>[\"type\"]> }\n\n\nexport type Model<DB extends IndexedDBConfig, SN extends StoreName<DB>> =\n  StoreIdModel<DB, SN> & StoreIxModel<DB, SN> & StoreXModel<DB, SN>;\n\n","import { useMemo } from \"react\";\nimport { CreateObjectStore, DBOperations, IndexedDBConfig, Key, Model, StoreIdKey, StoreName } from \"./indexed-db\";\n\n/**\n * @deprecated use IndexedDBConfig\n */\nexport type IndexedDBProps = IndexedDBConfig;\n\nexport interface useIndexedDB {\n  dbName: string;\n  version: number;\n  objectStore: string;\n}\n\nconst indexeddbConfiguration: { version: number; name: string } = {\n  version: null,\n  name: null,\n};\n\nexport function initDB({ name, version, objectStoresMeta }: IndexedDBConfig) {\n  indexeddbConfiguration.name = name;\n  indexeddbConfiguration.version = version;\n  Object.freeze(indexeddbConfiguration);\n  CreateObjectStore(name, version, objectStoresMeta);\n}\n\nexport function useIndexedDB<DB extends IndexedDBConfig, SN extends StoreName<DB> = StoreName<DB>>(objectStore: SN): {\n  add: <T extends Model<DB, SN>>(value: Omit<T, StoreIdKey<DB, SN>>, key?: any) => Promise<number>;\n  getByID: <T extends Model<DB, SN>>(id: number | string) => Promise<T>;\n  getAll: <T extends Model<DB, SN>>() => Promise<T[]>;\n  update: <T extends Model<DB, SN>>(value: T, key?: any) => Promise<any>;\n  deleteRecord: (key: Key) => Promise<any>;\n  openCursor: (\n    cursorCallback: (event: Event) => void,\n    keyRange?: IDBKeyRange,\n  ) => Promise<void>;\n  getByIndex: (indexName: string, key: any) => Promise<any>;\n  clear: () => Promise<any>;\n} {\n  if (!indexeddbConfiguration.name || !indexeddbConfiguration.version) {\n    throw new Error(\"Please, initialize the DB before the use.\");\n  }\n  return useMemo(\n    () =>\n      DBOperations(\n        indexeddbConfiguration.name,\n        indexeddbConfiguration.version,\n        objectStore,\n      ),\n    [indexeddbConfiguration, objectStore],\n  );\n}\n","module.exports = require(\"react\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(629);\n"],"names":["validateStoreName","db","storeName","objectStoreNames","contains","reject","options","trans","transaction","dbMode","onerror","error","oncomplete","complete","onabort","abort","type","resolve","e","database","mode","createTransaction","buildOptions","store","objectStore","createDatabaseTransaction","DBMode","readonly","readwrite","AccessDB","IndexedDB","IndexedDBContext","createContext","name","version","IndexedDBProvider","Provider","IndexedDBCosumer","Consumer","children","forEach","schema","openDatabase","event","currentTarget","result","createObjectStore","storeConfig","storeSchema","createIndex","keyPath","value","DBOperations","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","dbName","upgradeCallback","Promise","request","open","onsuccess","onupgradeneeded","storeSchemas","target","close","currentStore","add","key","then","createReadwriteTransaction","evt","getByID","id","validateBeforeTransaction","createReadonlyTransaction","get","getAll","update","put","deleteRecord","delete","clear","openCursor","cursorCallback","keyRange","getByIndex","indexName","index","indexeddbConfiguration","objectStoresMeta","Object","freeze","CreateObjectStore","Error","useMemo","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}